import OpenAI from "openai";
import { NextRequest } from "next/server";

import { put } from "@vercel/blob";

export async function GET(request: NextRequest) {
  const param = request.nextUrl.searchParams.get("scene");

  if (!param) {
    return new Response("Please provide a message", { status: 400 });
  }

  const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
  });

  const completion = await openai.chat.completions.create({
    model: "gpt-4-1106-preview",
    messages: [
      {
        role: "system",
        content:
          '- **Reply Format:** Your responses must exclusively be in JSON format. The JSON object should have two keys: `html` and `runAnimation`, both containing string values. Do not include ```json ``` . Only JSON.\n\nFor your style, you will use Zen and Buddhist Aesthetics.\n\n- **Design HTML Elements:** Create the required HTML elements for the scene. Use inline CSS for styles and positioning, and ensure each element has a unique identifier.\n\nAlso know that the animation will have fit inside this frame div: <div style="width:500px;height:500px;border:1px solid black;position:relative;overflow:hidden"></div>. So make sure that the animation looks good inside these bounds.\n\n\nMake sure to use the z-index property to define which elements should go over which.\n\nYou can also use the font awesome library to include icons. For example, if you are being asked to make an animation of a hippo, you could use the font awesome icon like this:\n\n<FontAwesomeIcon icon="fa-duotone fa-hippo" />\n\nHere are some icons you could use:\n\n hand-grab-o \n hand-lizard-o\n hand-o-down\n hand-o-left\n hand-o-right\n hand-o-up\n hand-paper-o\n hand-peace-o\n hand-pointer-o\n hand-rock-o\n hand-scissors-o\n hand-spock-o\n hand-stop-o \n thumbs-down\n thumbs-o-down\n thumbs-o-up\n thumbs-up\namerican-sign-language-interpreting\nasl-interpreting \nassistive-listening-systems\naudio-description\nblind\nbraille\ncc\ndeaf\ndeafness \nhard-of-hearing \nlow-vision\nquestion-circle-o\nsign-language\nsigning \ntty\nuniversal-access\nvolume-control-phone\nwheelchair\nwheelchair-alt\nambulance\nautomobile \nbicycle\nbus\ncab \ncar\nfighter-jet\nmotorcycle\nplane\nrocket\nship\nspace-shuttle\nsubway\ntaxi\ntrain\ntruck\nwheelchair\nwheelchair-alt\n\n\n- **Write JavaScript for Animation:** Write JavaScript for Animation: Utilize Motion One\'s functions to create dynamic animations. \n\nHow to animate:\n\n---\n\nAnimate\n\nAlways create animations that loop endlessly and mimic the calm natural breathing of a person.\n\nHere is an example animation with the desired style:\n\n---\nconst runAnime = () => {\n  motion.animate(\n    ".sun",\n    {\n      scale: 4,\n      rotate: 180,\n      width: 100,\n      margin: 100,\n    },\n    {\n      duration: 5, // slow and smooth\n      easing: "ease-in-out", // makes it smooth and relaxing\n      repeat: Infinity, // Loops forever\n      direction: "alternate", // Runs forward, then backward\n    }\n  );\n\n    // Multiple animations on a single element makes the scene more interesting and vibrant\n\n  motion.animate(\n    ".sun",\n    {\n      x: "800%",\n    },\n    {\n      duration: 15, // slow and smooth\n      easing: "ease-in-out", // makes it smooth and relaxing\n      repeat: Infinity, // Loops forever\n      direction: "alternate", // Runs forward, then backward\n    }\n  );\n\n  motion.animate(\n    ".sun",\n    {\n      backgroundColor: "red",\n    },\n    {\n      duration: 0.5, // fast and snappy\n      easing: "ease-in-out", // makes it smooth and relaxing\n      repeat: Infinity, // Loops forever\n      direction: "alternate", // Runs forward, then backward\n    }\n  );\n\n  motion.animate(\n    ".sun",\n    {\n      borderRadius: ["100%", "25%"],\n    },\n    {\n      duration: 3,\n      easing: "ease-in-out", // makes it smooth and relaxing\n      repeat: Infinity, // Loops forever\n      direction: "alternate", // Runs forward, then backward\n    }\n  );\n};\n\nconst Sun = () => (\n  <div\n    className="sun"\n    style={{\n      width: "30px",\n      height: "30px",\n      borderRadius: "25%",\n      backgroundColor: "yellow",\n      margin: "10px",\n    }}\n  ></div>\n);\n---\n\nAs you can see the animations are many and complex, this is meant to make it more engaging and entertaining for the viewer. This is the main purpose, to mesmerize the viewer with beautiful animations.  \n\n\nAlways animate the background to change color in psychedelic ways, and to also create textures. The animation should feel like it\'s breathing\n\nDocs:\nanimate can animate a DOM element or multiple elements to a set of CSS styles:\n\nimport { animate } from "motion"\n\n// Animate via selector\nanimate(".box", { x: 100 }, { duration: 1 })\n\n// Animate element or array of elements\nconst boxes = document.querySelectorAll(".box")\nanimate(boxes, { opacity: 0 }, { easing: "ease-out" })\n\nIt can also accept a function, which outputs a progress value between 0 and 1, which you can use to animate anything:\n\nimport { animate } from "motion"\n\nanimate(\n  (progress) => {\n    box.innerHTML = progress\n  },\n  { duration: 0.5 }\n)\n\nKeyframes\nSingle keyframe\nBy passing a single keyframe, the element will animate from its current style to those defined in the keyframe:\n\nanimate(element, {\n  opacity: 1,\n  transform: "rotate(360deg)",\n})\n\nMultiple keyframes\nBy defining a value as an array, it\'ll animate through each keyframe in turn:\n\nanimate(element, {\n  transform: ["rotate(90deg)", "translateX(100px) rotate(45deg)", "none"],\n})\n\nWildcards\nnull is a special wildcard. As the first keyframe, it\'ll be replaced by the current value as read from the DOM.\n\nelement.style.opacity = "0.5"\n\nanimate(element, {\n  opacity: [\n    null, // 0.5\n    0.8,\n    1,\n  ],\n})\n\nSubsequent null values will be replaced by the previous keyframe. Useful for keeping a style static for some of the animation. This way, you only have to change it in one place if you want to tweak the animation.\n\nanimate(element, {\n  x: [\n    0,\n    100,\n    null, // 100\n    200,\n  ],\n})\n\nCustom keyframe timing\nBy default, each of these keyframes will be spaced evenly throughout the animation. It\'s also possible to specify a list of offsets, values between 0 and 1, that defines a relative point in the animation a specific keyframe should be hit:\n\nanimate(\n  element,\n  {\n    transform: ["rotate(90deg)", "translateX(100px) rotate(45deg)", "none"],\n  },\n  { offset: [0, 0.25, 1] }\n)\n\nIf there are fewer keyframes than offsets defined in offset, the other keyframes will be spaced evenly:\n\nanimate(\n  element,\n  { color: ["red", "yellow", "green", "blue"] },\n  { offset: [0, 0.2] } // [...0.6, 1]\n)\n\nCustom keyframe easing\nBy default, easing will apply to the progress of whole animation. It\'s also possible to define easing between specific keyframes by defining an easing option as any array:\n\nanimate(\n  element,\n  { color: ["red", "yellow", "green", "blue"] },\n  { easing: ["ease-in", "linear", "ease-out"] }\n)\n\nOptions\nOptions can be defined either for all values:\n\nanimate(\n  element,\n  { opacity: 0, color: ["red", "yellow", "green", "blue"] },\n  { duration: 2 }\n)\n\nOr overridden for individual values:\n\nanimate(\n  element,\n  { opacity: 0, color: ["red", "yellow", "green", "blue"] },\n  {\n    duration: 2,\n    ease: "linear",\n    opacity: { duration: 0.4 },\n  }\n)\n\nduration\nDefault: 0.3\n\nA duration, in seconds, that the animation will take to complete.\n\nanimate(element, { backgroundColor: "red" }, { duration: 2 })\n\ndelay\nDefault: 0\n\nA duration, in seconds, that the animation will be delayed before starting.\n\nanimate(element, { backgroundColor: "red" }, { delay: 0.5 })\n\nWhen animating multiple elements, the stagger function can be used to offset the delay by increasing amounts across each element:\n\nimport { animate, stagger } from "motion"\n\nanimate(element, { backgroundColor: "red" }, { delay: stagger(0.1) })\n\nendDelay\nDefault: 0\n\nA duration, in seconds, that the animation will wait at the end before ending.\n\nanimate(element, { backgroundColor: "red" }, { endDelay: 0.5, repeat: 2 })\n\neasing\nDefault: "ease"\n\nAn easing to use for the whole animation, or list of easings to use between individual keyframes.\n\nAccepted easing options are:\n\nBasic easings: "linear", "ease", "ease-in", "ease-out", "ease-in-out"\nCubic bezier curve: e.g. [.17,.67,.83,.67]\nStepped easing: e.g. "steps(2, start)"\nCustom easing: A JavaScript easing function, for example this bounce easing function.\nProvide a single easing to ease the animation as a whole:\n\nanimate(element, { transform: "rotate(90deg)" }, { easing: "steps(2, start)" })\n\nOr an array to specifically ease between individual keyframes:\n\nanimate(element, { scale: [0, 1, 2] }, { easing: ["ease-in", "ease-out"] })\n\nNote on custom easing: Custom easing support for WAAPI animations is based on the new linear() easing spec.\n\nIf a browser doesn\'t yet support linear() and the value being animated is not an independent transform (x, scale etc), Motion One will fallback to "ease".\n\ndirection\nDefault: "normal"\n\nThe direction of animation playback. "normal", "reverse", "alternate", or "alternate-reverse".\n\nanimate(element, { transform: "rotate(90deg)" }, { direction: "reverse" })\n\nrepeat\nDefault: 0\n\nThe number of times the animation should repeat. Set to Infinity to repeat indefinitely.\n\nanimate(element, { transform: "rotate(90deg)" }, { repeat: Infinity })\n\nallowWebkitAcceleration\nDefault: false\n\nBecause of numerous timing bugs in Webkit\'s accelerated animations, these are disabled by default in Webkit-powered browsers.\n\nHowever, if the your animation is being disrupted by heavy processing, you can allow acceleration with this setting. It\'s advised you test these animations thoroughly in both Safari and iOS Chrome.\n\nanimate(element, { transform: "scale(2)" }, { allowWebkitAcceleration: true })\n\nIf and when Webkit\'s implementation improves, this option will default to true.\n\nautoplay\nDefault: true\n\nWhether the animation should start automatically.\n\nanimate(element, { transform: "scale(2)" }, { autoplay: false })\n\n\n---\n\nTimeline\n\nCreate complex sequences of animations across multiple elements.\n\nimport { timeline } from "motion"\n\ntimeline(sequence, options)\n\nSequence\nThe timeline\nThe timeline sequence is an array:\n\nconst sequence = []\n\nThis sequence defines animations with the same settings as the animate function:\n\nconst sequence = [\n  ["nav", { x: 100 }, { duration: 1 }]\n];\n\nBy default, animations will play one after another:\n\nconst sequence = [\n  ["nav", { x: 100 }, { duration: 1 }],\n  ["nav li", { opacity: 1 }, { duration: 0.3, delay: stagger(0.1) }],\n]\n\nat\nThe timing of subsequent animations can be adjusted with the at option.\n\nPass a number to define a specific time:\n\nconst sequence = [\n  ["nav", { opacity: 1 }],\n  // This will start 0.5 from the start of the whole timeline:\n  ["nav", { x: 100 }, { at: 0.5 }],\n]\n\nPass a string starting with + or - to start relative to the end of the previous animation:\n\nconst sequence = [\n  ["nav", { opacity: 1 }],\n  // This will start 0.5 seconds after the previous animation:\n  ["nav", { x: 100 }, { at: "+0.5" }],\n  // This will start 0.2 seconds before the end of the previous animation:\n  ["nav li", { opacity: 1 }, { at: "-0.2" }],\n]\n\nOr pass "<" to start at the same time as the previous segment:\n\nconst sequence = [\n  ["nav", { opacity: 1 }, { duration: 1 }],\n  ["nav", { x: 100 }, { duration: 1 }],\n  // This will start at the same time as the x: 100 animation\n  ["nav li", { opacity: 1 }, { at: "<" }],\n]\n\nLabels\nBy passing a string in the sequence you can mark that time with a label, to later refer to it with an at:\n\nconst sequence = [\n  ["nav", { opacity: 1 }, { duration: 2 }],\n  "my label",\n\nIn the above example, "my label" will be set to the 2 second mark. Later in the sequence, you can refer to the 2 second mark in at by using this label:\n\n["nav li", { opacity: 1 }, { at: "my label" }],\n\nAlternatively, a label can be set absolutely or relatively by passing it as an object with its own at property:\n\nconst sequence = [\n  ["nav", { opacity: 1 }, { duration: 2 }],\n  { name: "my label", at: "-0.5" },\n\nHere, "my label" will be set to the 1.5 second mark.\n\nForward-filling keyframes\nWhen defining a segment with multiple keyframes, the first keyframe will be forward-filled to the start of the animation.\n\nSo in this example, button elements will be set to opacity: 0 at the very start of the animation, and then begin animating after 0.5 seconds:\n\nconst sequence = [["button", { opacity: [0, 1] }, { at: 0.5 }]]\n\nOptions\nduration\nDefault: Automatically calculated\n\nA duration, in seconds, that the animation will take to complete.\n\ntimeline(sequence, { duration: 4 })\n\nBy default, this is automatically calculated by the provided sequence. But if provided explicitly, the whole animation will be scaled to fit this duration.\n\ndelay\nDefault: 0\n\nA duration, in seconds, that the animation will be delayed before starting.\n\ntimeline(sequence, { delay: 0.5 })\n\nendDelay\nDefault: 0\n\nA duration, in seconds, that the animation will wait at the end before ending.\n\ntimeline(sequence, { endDelay: 0.5 })\n\ndirection\nDefault: "normal"\n\nThe direction of animation playback. "normal", "reverse", "alternate", or "alternate-reverse".\n\ntimeline(sequence, { direction: "alternate", repeat: 2 })\n\nrepeat\nDefault: 0\n\nThe number of times the animation should repeat. Set to Infinity to repeat indefinitely.\n\ntimeline(sequence, { repeat: 2 })\n\ndefaultOptions\nAn object of options to use as the default options for each animation in the sequence.\n\ntimeline(sequence, {\n  defaultOptions: { ease: "ease-in-out" },\n})\n\n\n---\n\nStagger\n\nstagger\nContents\nOptions\nstagger is used to offset the start time of each animation.\n\nstagger(duration, options)\n\nWhen defining an animation with one or more elements, delay can be set with the stagger function to delay each element\'s animation by a specific duration:\n\nimport { animate, stagger } from "motion"\n\nanimate("li", { x: 100 }, { delay: stagger(0.1) })\n\nOptions\nstart\nDefault: 0\n\nstagger(0.1, { start: 0.2 }) // 0.2, 0.3, 0.4...\n\nfrom\nDefault: "first"\n\nSpecifies an element position from which to stagger. Can be set as "first", "center", "last", or a number to specify an index.\n\nanimate(\n  [a, b, c],\n  { x: 100 },\n  { delay: stagger(0.1, { from: "last" }) } // 0.2, 0.1, 0\n)\n\neasing\nDefault: "linear"\n\nApplies easing to the duration so the interval between delays becomes longer or shorter over each animation.\n\nCan be set in the same way as animate easing option, or as an easing function.\n\nanimate(\n  "li", \n  { opacity: 1 }, \n  { delay: stagger(0.2, { easing: "ease-out" }) }\n);\n\n---\n\nSpring\n\nspring\nContents\nVelocity\nOptions\nLimitations\nThe spring function animates transforms using real spring physics. This produces more natural-feeling animations.\n\nimport { animate, spring } from "motion"\n\nindex.html\nindex.js\nimport { animate, spring } from "motion"\n\nanimate(\n  "#box",\n  { rotate: 90 },\n  { easing: spring() }\n)\n  \n  \n\nspring accepts options to customise your spring. Copy/paste { stiffness: 300, damping: 10 } into the spring function in the above example to see how it changes the animation.\n\nNote: Because spring is a simulation, any provided duration will be overridden.\n\nspring will use real springs to animate independent transforms like x, scale and rotate. All other values will use the defined spring to figure out how long it takes to reach its overshoot point (the bouncy bit) and will automatically create an animation to match.\n\nindex.html\nindex.js\nimport { animate, spring } from "motion"\n\nanimate(\n  "#box",\n  { scale: 2, opacity: 1 },\n  { easing: spring() }\n)\n\nThis means that animating values like opacity with a bouncy spring won\'t create odd flashing effects.\n\nVelocity\nspring will automatically pass velocity from any running animations into the next one, so interrupting an animation will feel natural.\n\nThis can be overridden by manually passing velocity to spring. velocity is measured as units per second.\n\nanimate(\n  "#ball",\n  { x: 100 },\n  { easing: spring({ velocity: 1000 }) }\n})\n\nIf you want to pass a different velocity per value (for instance for animating at the end of a pointer gesture) you can create value-specific options:\n\nanimate(\n  "#ball",\n  { x: 0, y: 0 },\n  {\n    x: { easing: spring({ velocity: 200 }) },\n    y: { easing: spring({ velocity: 500 }) }\n  }\n})\n\nOptions\nstiffness\nDefault: 100\n\nThe attraction force of a spring. Higher values create faster, sharper movement.\n\nspring({ stiffness: 500 })\n\ndamping\nDefault: 10\n\nThe opposing force of a spring. Higher values reduce the bounciness of the spring.\n\nspring({ damping: 100 })\n\nmass\nmass affects the inertia of a value. Higher values will be slower to start moving and slower to stop.\n\nDefault: 1\n\nspring({ mass: 2 })\n\nrestSpeed\nDefault: 2, or 0.05 for scale\n\nA speed (in absolute units per second) below which the spring animation is considered finished.\n\nspring({ restSpeed: 1 })\n\nrestDistance\nDefault: 0.5, or 0.01 for scale\n\nA distance from the animation target, below which the spring animation is considered finished.\n\nspring({ restDistance: 0.1 })\n\nvelocity\nDefault: 0, or the value\'s current velocity\n\nThe velocity (in units per second) at which to start the spring animation.\n\nspring({ velocity: 1000 })\n\nLimitations\nThere are currently some limitations with the glide easing.\n\nLimited duration\nSprings with 0 damping can last an infinite amount of time, but the Web Animations API needs a finite duration. So springs currently max out at 10 seconds (which is more than long enough for the vast majority of UI animations).\n\nIncrease damping relative to stiffness to decrease the duration of your animation.\n\nTimeline keyframes\nspring is supported in timeline but independent transforms must be defined with start and end keyframes: { x: [0, 100] }.\n\nNo hardware acceleration\nspring only works with independent transforms, which are not yet hardware accelerated in browsers.\n\n---\n\nGlide\n\nglide\nContents\nVelocity\nBoundaries\nOptions\nLimitations\nglide can animate transforms using momentum physics. This is great for creating scroll momentum animations.\n\nimport { animate, glide } from "motion"\n\nindex.html\nindex.js\nimport { animate, glide } from "motion"\n\nanimate(\n  "#carousel",\n  { x: 0 },\n  { easing: glide({ velocity: -500 }) }\n)\n  \n\n\nNote: glide is a simulation, so provided target keyframes and duration will be overridden.\n\nVelocity\nglide will automatically pass velocity from any running animations into the next one, so interrupting an animation will feel natural.\n\nThis can be overridden by manually passing velocity to glide. velocity is measured as units per second.\n\nanimate(\n  "#carousel",\n  { x: 100 },\n  { easing: glide({ velocity: 1000 }) }\n})\n\nIf you want to pass a different velocity per value (for instance for animating at the end of a pointer gesture) you can create value-specific options:\n\nanimate(\n  "#carousel",\n  { x: 0, y: 0 },\n  {\n    x: { easing: glide({ velocity: 200 }) },\n    y: { easing: glide({ velocity: 500 }) }\n  }\n})\n\nBoundaries\nBy setting min and/or max you can set boundaries to the glide animation. If the animated value exceeds these boundaries, a spring animation will start to catch the value and animate it to the exceeded boundary.\n\nindex.html\nindex.js\nimport { animate, glide } from "motion"\n  \nanimate(\n  "#carousel",\n  { x: 0 },\n  {\n    easing: glide({\n      velocity: -1200,\n      min: -800,\n      bounceStiffness: 500,\n      bounceDamping: 20\n    })\n  }\n)\n\n\nOptions\nvelocity\nDefault: 0, or the value\'s current velocity\n\nThe velocity (in units per second) at which to start the glide animation.\n\nglide({ velocity: 1000 })\n\npower\nDefault: 0.8\n\npower influences how much of the initial velocity is factored into the animation, and thus how far the animation will glide.\n\nHigher values will throw the animation further and feel lighter, whereas lower values will feel heavier.\n\nglide({ power: 2 })\n\ndecay\nDefault: 0.325\n\nA time constant (in seconds) used to calculate velocity decay.\n\nHigher values lead to longer animations with more gradual deceleration and a lighter feel.\n\nglide({ decay: 0.5 })\n\nchangeTarget\nThe glide animation automatically calculates a target to animate to. By setting changeTarget, you can take this calculated target and return a new one.\n\nFor instance, the function in the following example will snap the target to the next 100:\n\nconst roundTo = 100\nglide({\n  changeTarget: (target) => Math.ceil(target / roundTo) * roundTo,\n})\n\nmin\nA minimum boundary for the glide animation. If the animated value exceeds this boundary, a spring animation will take over to snap the value to min.\n\nglide({ min: -100 })\n\nmax\nA maximum boundary for the glide animation. If the animated value exceeds this boundary, a spring animation will take over to snap the value to max.\n\nglide({ max: -100 })\n\nrestDistance\nDefault: 0.5, or 0.01 for scale\n\nA distance from the animation target, below which the glide animation is considered finished.\n\nglide({ restDistance: 0.1 })\n\nbounceStiffness\nDefault: 100\n\nThe attraction force of the spring used if the animation exceeds the boundaries defined by min or max. Higher values create faster, sharper movement.\n\nglide({ max: 100, bounceStiffness: 500 })\n\nbounceDamping\nDefault: 10\n\nThe opposing force of the spring used if the animation exceeds the boundaries defined by min or max. Higher values reduce the bounciness of the spring.\n\nglide({ max: 100, bounceDamping: 500 })\n\nrestSpeed\nDefault: 2, or 0.05 for scale\n\nA speed (in absolute units per second) below which the bounce spring animation is considered finished.\n\nglide({ restSpeed: 1 })\n\nLimitations\nThere are currently a couple of limitations with the glide easing.\n\nLimited duration\nGlide animations with higher timeConstants will take longer to finish, but the Web Animations API needs a finite duration. So they currently max out at 10 seconds.\n\nLower the timeConstant to shorten the duration of the animation.\n\nTimeline\nglide is supported in timeline but there are two requirements:\n\nAnimations on a timeline don\'t currently pass velocity throughout the animation sequence, so this needs to be provided manually through the glide() function.\nglide animations in a timeline need to be defined with a start and end keyframe: { x: [0, 100] }.\nNo hardware acceleration\nglide only works with independent transforms, which are not yet hardware accelerated in browsers.\n\n---\n\nExamples\n\nContents\nSVG loading spinner\nSVG path drawing timeline\nScroll-triggered animation\nAnimating HTML text\nMorph SVG path\nP5\nScroll\nCustom easing function\nSVG loading spinner\nindex.js\nstyles.css\nindex.html\nimport "./styles.css"\nimport { animate, stagger } from "motion"\n  \nconst numSegments = document.querySelectorAll(".segment").length\n\n/**\n * Stagger offset (in seconds)\n * Decrease this to speed the animation up or increase\n * to slow it down.\n */\nconst offset = 0.09\n\nsetTimeout(() => {\n  animate(\n    ".segment",\n    { opacity: [0, 1, 0] },\n    {\n      offset: [0, 0.1, 1],\n      duration: numSegments * offset,\n      delay: stagger(offset),\n      repeat: Infinity,\n    }\n  )\n}, 1000)\n  \n\n\nSVG path drawing timeline\nindex.js\nindex.html\nimport "./styles.css"\nimport { timeline } from "motion"\n  \n/**\n * Remember to set the pathLength="1" SVG attribute on\n * the elements you want to draw. This makes it easy\n * to use the same animation logic for elements of a\n * different path length.\n */\n\nconst draw = (progress) => ({\n  // This property makes the line "draw" in when animated\n  strokeDashoffset: 1 - progress,\n\n  // Each line will be hidden until it starts drawing\n  // to fix a bug in Safari where the line can be\n  // partially visible even when progress is at 0\n  visibility: "visible",\n})\n\ntimeline([\n  ["circle", draw(1), { duration: 0.8, delay: 1 }],\n  ["path", draw(1), { duration: 0.6, at: "-0.2" }],\n])\n\n  \n\n\nScroll-triggered animation\nindex.js\nindex.html\nimport { inView, animate } from "motion";\n\ninView("section", ({ target }) => {\n  animate(\n    target.querySelector("span"),\n    { opacity: 1, transform: "none" },\n    { delay: 0.2, duration: 0.9, easing: [0.17, 0.55, 0.55, 1] }\n  );\n});\n  \n\n\nAnimating HTML text\nindex.js\nstyles.css\nindex.html\nimport "./styles.css"\nimport { animate } from "motion"\n\nsetTimeout(() => {\n  const h1 = document.querySelector("h1")\n\n  animate(\n    (progress) => h1.innerHTML = Math.round(progress * 100),\n    { duration: 2, easing: "ease-out" }\n  )\n}, 1000)\n  \n\nMorph SVG path\nindex.js\npaths.js\nindex.html\nimport { animate } from "motion";\nimport { interpolate } from "flubber";\nimport { paths } from "./paths";\n\nconst path = document.querySelector("path");\n\nlet currentPath = paths.star;\n\npath.setAttribute("fill", currentPath.color);\npath.setAttribute("d", currentPath.d);\n\nconst transition = { duration: 0.5 };\n\nfunction togglePath() {\n  currentPath = currentPath === paths.star ? paths.heart : paths.star;\n\n  const mixPaths = interpolate(path.getAttribute("d"), currentPath.d, {\n    maxSegmentLength: 0.1\n  });\n\n  animate(path, { fill: currentPath.color }, transition);\n  animate((progress) => path.setAttribute("d", mixPaths(progress)), transition);\n}\n\nsetTimeout(togglePath, 1000);\n\npath.addEventListener("click", togglePath);\n \n\n\nYour code should:\n\nSelect Elements: Target HTML elements using their unique identifiers for animation.\nAnimation Properties: Define key animation properties for each element. These include:\nposition to specify the element\'s location on the screen.\nrotation for angular movement.\nscale to alter the size of the element.\nopacity to change the visibility from transparent (0) to fully visible (1).\nAnimation Parameters: Set parameters for a smooth and natural animation effect. These parameters include:\nduration to define how long the animation should run.\neasing to control the animation\'s acceleration and deceleration (e.g., linear, ease-in, ease-out).\ndelay to specify a waiting period before the animation starts.\nExample Usage: Here is a basic example of animating an element with a unique ID exampleElement:\n\n\nMotionOne.animate(\'#exampleElement\', \n  { scale: 1.5, rotate: 180, opacity: 0.5 },\n  { duration: 2.0, easing: \'ease-out\', delay: 0.5 }\n);\nCustomization: Adapt and expand these principles based on the scene\'s requirements. The goal is to bring the scene to life through engaging and appropriate animations. \n\nWhen writing the script, assume that there is a global \'MotionOne\' object with the api. Do not include any imports. this is very important, it means that every time you are calling the API, you need to use like this:\n\nMotionOne.animate( ... );\n\n- **Combine into JSON Output:** Format the HTML and JavaScript as strings. Construct a JSON object with `html` containing the HTML string, and `runAnimation` containing the JavaScript animation code. Ensure the code is ready to run in a compatible environment.\n\n- **JSON Template:**\n{ "htlm": "", runAnimation: ""}\n',
      },
      {
        role: "user",
        content: param,
      },
    ],
    temperature: 0.55,
    max_tokens: 4095,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
  });

  const animation = completion.choices[0].message.content;

  if (animation) {
    await put(param, animation, {
      access: "public",
    });

    console.log("animation", { animation });
    return new Response(JSON.stringify({ animation }), {
      headers: {
        "content-type": "application/json;charset=UTF-8",
      },
    });
  }

  return new Response("No message found", { status: 404 });
}
